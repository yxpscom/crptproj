<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>About Exceptions and Exception Handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="style.css" rel="stylesheet" type="text/css">
<link rel="icon" href="../favicon.ico" type="image/x-icon" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="$relpath/search.js"></script>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div style="padding:10px">
<table border="0" bgcolor="#FFFFFF" cellspacing="5" width="100%">
 <tr>
  <td width="24px" rowspan="2"><img src="../logo.png" alt="Logo" /></td>
  <td><font family="Arial" size="+2">crashrpt</font></td>
  <td rowspan="2" align="right"></td>
 </tr>
 <tr>
  <td colspan="2"><span style="font-size:0.9em"><i>A crash reporting system for Windows applications</i></a></td>
 </tr>
</table>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">CrashRpt Documentation</a></li><li class="navelem"><a class="el" href="other_topics.html">Other Topics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">About Exceptions and Exception Handling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Reading this page is not necessary for using CrashRpt. However read this page if you need extended knowledge of exception handling.</p>
<p>This page describes techniques of handling exceptions in Visual C++ programs under Windows. CrashRpt uses the techniques described below internally.</p>
<p>The page covers the following topics:</p>
<ul>
<li><a class="el" href="exception_handling.html#about_exceptions">About Exceptions</a></li>
<li><a class="el" href="exception_handling.html#structured_exc">Structured Exception Handling</a></li>
<li><a class="el" href="exception_handling.html#vectored_exc">Vectored Exception Handling</a></li>
<li><a class="el" href="exception_handling.html#crt_errors">CRT Error Handling</a></li>
<li><a class="el" href="exception_handling.html#cpp_signals">C++ Signal Handling</a></li>
<li><a class="el" href="exception_handling.html#getting_exception_context">Retrieving Exception Information</a></li>
<li><a class="el" href="exception_handling.html#cxx_compiler_flags">Visual C++ Compiler Flags</a></li>
<li><a class="el" href="exception_handling.html#crt_version_and_dll">Exception Handling and CRT Linkage</a></li>
<li><a class="el" href="exception_handling.html#exception_handling_reference">Reference</a></li>
</ul>
<h1><a class="anchor" id="about_exceptions"></a>
About Exceptions</h1>
<p>An exception or a critical error typically means that a program stops working normally and needs to stop its execution.</p>
<p>For example, an exception may occur because of the following:</p>
<ul>
<li>program accesses an invalid memory address (such as NULL pointer)</li>
<li>stack is overflown due to infinite recursion</li>
<li>large block of data is written to a small buffer</li>
<li>a pure virtual method of a C++ class is called</li>
<li>memory buffer can't be allocated (out of memory)</li>
<li>invalid parameter is passed to a C++ system function</li>
<li>C run-time libraries detect an error and request program termination</li>
</ul>
<p>There are two kinds of exceptions that have different nature: SEH exceptions (Structured Exception Handling, SEH) and typed C++ exceptions.</p>
<p>SEH exceptions were designed for C language, but they can be used in C++, too. They are handled using __try{}__except(){} construction. SEH exceptions are Visual C++ compiler-specific. You shouldn't use structured exception handling if you write portable code.</p>
<p>C++ typed exceptions are handled using try{}catch{} construction. Example (taken from <a href="http://www.cplusplus.com/doc/tutorial/exceptions/">http://www.cplusplus.com/doc/tutorial/exceptions/</a>):</p>
<div class="fragment"><div class="line"><span class="comment">// exceptions</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span>std;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main () {</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keywordflow">throw</span> 20;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> e)</div><div class="line">  {</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;An exception occurred. Exception Nr. &quot;</span> &lt;&lt; e &lt;&lt; endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="structured_exc"></a>
Structured Exception Handling</h1>
<p>When a SEH exception occurs, you typically see a pop-up window (Dr.Watson) that offers to send error report to Microsoft.</p>
<p>You can generate a SEH exception yourself using <b>RaiseException()</b> function.</p>
<p>You can catch a SEH exception in your code using __try{}__except(Expression){} construction. The <b>main()</b> function of your program is guarded with such construction, so by default all unhandled SEH exceptions are caught and Dr.Watson is invoked.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>* p = NULL;   <span class="comment">// pointer to NULL</span></div><div class="line">__try</div><div class="line">{</div><div class="line">  <span class="comment">// Guarded code</span></div><div class="line"></div><div class="line">  *p = 13; <span class="comment">// causes an access violation exception;</span></div><div class="line">}</div><div class="line">__except(EXCEPTION_EXECUTE_HANDLER) <span class="comment">// Here is exception filter expression</span></div><div class="line">{  </div><div class="line">  <span class="comment">// Here is exception handler</span></div><div class="line"></div><div class="line">  <span class="comment">// Terminate program</span></div><div class="line">  ExitProcess(1);</div><div class="line">}</div></div><!-- fragment --><p>Each SEH exception has an associated exception code. You can extract the exception code inside of __except statement using <b>GetExceptionCode()</b> intrinsic function. You can extract exception information inside of __except statement using <b>GetExceptionInformation()</b> intrinsic function. To use these intrinsic functions you usually create your custom exception filter as shown in the example below.</p>
<p>The following example shows how to use a SEH exception filter.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> seh_filter(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> code, <span class="keyword">struct</span> _EXCEPTION_POINTERS* ep)</div><div class="line">{</div><div class="line">  <span class="comment">// Generate error report</span></div><div class="line"></div><div class="line">  <span class="comment">// Execute exception handler</span></div><div class="line">  <span class="keywordflow">return</span> EXCEPTION_EXECUTE_HANDLER;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">  __try</div><div class="line">  {</div><div class="line">    <span class="comment">// .. some buggy code here</span></div><div class="line">  }</div><div class="line">  __except(seh_filter(GetExceptionCode(), GetExceptionInformation()))</div><div class="line">  {    </div><div class="line">    <span class="comment">// Terminate program</span></div><div class="line">    ExitProcess(1);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The __try{}__except(){} construction is mostly C oriented. However, you can redirect a SEH exception to a C++ typed exception and handle it as you do with C++ typed exceptions. This can be done using the <b>_set_se_translator()</b> function provided by C++ runtime libraries (CRT).</p>
<p>Example taken from MSDN:</p>
<div class="fragment"><div class="line"><span class="comment">// crt_settrans.cpp</span></div><div class="line"><span class="comment">// compile with: /EHa</span></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;windows.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;eh.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> SEFunc();</div><div class="line"><span class="keywordtype">void</span> trans_func( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, EXCEPTION_POINTERS* );</div><div class="line"></div><div class="line"><span class="keyword">class </span>SE_Exception</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nSE;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    SE_Exception() {}</div><div class="line">    SE_Exception( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n ) : nSE( n ) {}</div><div class="line">    ~SE_Exception() {}</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getSeNumber() { <span class="keywordflow">return</span> nSE; }</div><div class="line">};</div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        _set_se_translator( trans_func );</div><div class="line">        SEFunc();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>( SE_Exception e )</div><div class="line">    {</div><div class="line">        printf( <span class="stringliteral">&quot;Caught a __try exception with SE_Exception.\n&quot;</span> );</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> SEFunc()</div><div class="line">{</div><div class="line">    __try</div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> x, y=0;</div><div class="line">        x = 5 / y;</div><div class="line">    }</div><div class="line">    __finally</div><div class="line">    {</div><div class="line">        printf( <span class="stringliteral">&quot;In finally\n&quot;</span> );</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> trans_func( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> u, EXCEPTION_POINTERS* pExp )</div><div class="line">{</div><div class="line">    printf( <span class="stringliteral">&quot;In trans_func.\n&quot;</span> );</div><div class="line">    <span class="keywordflow">throw</span> SE_Exception();</div><div class="line">}</div></div><!-- fragment --><p>The disadvantage of the __try{}__catch(Expression){} construction is that you may forget to guard a potentially incorrect code that may cause an exception that won't be handled by your program. However, such an unhandled SEH exception can be caught using the top-level unhandled exception filter set with the <b>SetUnhandledExceptionFilter()</b> function.</p>
<p>The exception information (CPU state before the exception occurred) is passed to the exception handler through <b>EXCEPTION_POINTERS</b> structure.</p>
<p>Example:</p>
<div class="fragment"><div class="line">LONG WINAPI MyUnhandledExceptionFilter(PEXCEPTION_POINTERS pExceptionPtrs)</div><div class="line">{</div><div class="line">  <span class="comment">// Do something, for example generate error report</span></div><div class="line"></div><div class="line">  <span class="comment">//..</span></div><div class="line"></div><div class="line">  <span class="comment">// Execute default exception handler next</span></div><div class="line">  <span class="keywordflow">return</span> EXCEPTION_EXECUTE_HANDLER; </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{ </div><div class="line">  SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);</div><div class="line"></div><div class="line">  <span class="comment">// .. some unsafe code here </span></div><div class="line">}</div></div><!-- fragment --><p>The top-level SEH exception handler works for all threads of the caller process, so its enough to call it once in the beginning of your <b>main()</b> function.</p>
<p>The top-level SEH exception handler is called in context of the thread where exception have occurred. This can affect the exception handler's ability to recover from certain exceptions, such as an invalid stack.</p>
<p>If your exception handler function is located inside of a DLL, be careful when using the <b>SetUnhandledExceptionFilter()</b> function. If your DLL is unloaded at the moment of crash, the behavior may be unpredictable.</p>
<h1><a class="anchor" id="vectored_exc"></a>
Vectored Exception Handling</h1>
<p>Vectored exception handling (VEH) is an extension to structured exception handling. It was introduced in Windows XP.</p>
<p>To add a vectored exception handler, you can use the <b>AddVectoredExceptionHandler()</b> function. The disadvantage is that VEH is available in WinXP and later, so the presence of <b>AddVectoredExceptionHandler()</b> function should be checked at run-time.</p>
<p>To remove the previously installed handler, use the <b>RemoveVectoredExceptionHandler()</b> function.</p>
<p>VEH allows to watch or handle <em>all</em> exceptions for the application. To preserve backward compatibility, when a SEH exception occurs in some part of the program, the system calls installed VEH handlers in turn, after that it searches for the usual SEH handlers.</p>
<p>An advantage of VEH is an ability to chain exception handlers, so if somebody installs vectored exception handler above yours, you still can intercept the exception.</p>
<p>Vectored exception handling is suitable when you need to monitor <em>ALL</em> exceptions, like a debugger does. But the problem is you have to decide which exception to handle and which to skip. In program's code, some exceptions may be intentionally guarded by __try{}__except(){} construction, and handling such exceptions in VEH and not passing it to frame-based SEH handler, you may introduce bugs into application logics.</p>
<p>VEH is currently not used by CrashRpt. <b>SetUnhandledExceptionFilter()</b> is more suitable, because it is the top-level SEH handler. If nobody handles the exception, top-level SEH handler is called and you don't need to decide if you should skip the exception or not.</p>
<h1><a class="anchor" id="crt_errors"></a>
CRT Error Handling</h1>
<p>In addition to SEH exceptions and C++ typed exceptions, C runtime libraries (CRT) provide their own error handling mechanism that should be taken into account in your program.</p>
<p>When CRT encounters an unhandled C++ typed exception, it calls <b>terminate()</b> function. To intercept such calls and take an appropriate action you should set error handler using <b>set_terminate()</b> function.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_terminate_handler()</div><div class="line">{</div><div class="line">  <span class="comment">// Abnormal program termination (terminate() function was called)</span></div><div class="line"></div><div class="line">  <span class="comment">// Do something here</span></div><div class="line"></div><div class="line">  <span class="comment">// Finally, terminate program</span></div><div class="line">  exit(1); </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">  set_terminate(my_terminate_handler);</div><div class="line"></div><div class="line">  terminate();</div><div class="line">}</div></div><!-- fragment --><p>There is <b>unexpected()</b> function that is not used with the current implementation of Visual C++ exception handling. However, consider using the <b>set_unexpected()</b> function to set handler for the <b>unexpected()</b> function, too.</p>
<dl class="section note"><dt>Note</dt><dd>In a multi-threaded environment, unexpected and terminate functions are maintained separately for each thread. Each new thread needs to install its own unexpected and terminate function. Thus, each thread is in charge of its own unexpected and terminate handling.</dd></dl>
<p>Use the <b>_set_purecall_handler()</b> function to handle pure virtual function calls. This function can be used in VC++ .NET 2003 and later. This function works for all threads of the caller process.</p>
<p>Example (taken from MSDN):</p>
<div class="fragment"><div class="line"><span class="comment">// _set_purecall_handler.cpp</span></div><div class="line"><span class="comment">// compile with: /W1</span></div><div class="line"><span class="preprocessor">#include &lt;tchar.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>CDerived;</div><div class="line"><span class="keyword">class </span>CBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   CBase(CDerived *derived): m_pDerived(derived) {};</div><div class="line">   ~CBase();</div><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(void) = 0;</div><div class="line"></div><div class="line">   CDerived * m_pDerived;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>CDerived : <span class="keyword">public</span> CBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   CDerived() : CBase(this) {};   <span class="comment">// C4355</span></div><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(void) {};</div><div class="line">};</div><div class="line"></div><div class="line">CBase::~CBase()</div><div class="line">{</div><div class="line">   m_pDerived -&gt; <span class="keyword">function</span>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myPurecallHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">   printf(<span class="stringliteral">&quot;In _purecall_handler.&quot;</span>);</div><div class="line">   exit(0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> _tmain(<span class="keywordtype">int</span> argc, _TCHAR* argv[])</div><div class="line">{</div><div class="line">   _set_purecall_handler(myPurecallHandler);</div><div class="line">   CDerived myDerived;</div><div class="line">}</div></div><!-- fragment --><p>Use the <b>_set_new_handler()</b> function to handle memory allocation faults. This function can be used in VC++ .NET 2003 and later. This function works for all threads of the caller process. Consider also using the <b>_set_new_mode()</b> function to define error behaviour for the <b>malloc()</b> function.</p>
<p>Example (taken from MSDN):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;new.h&gt;</span></div><div class="line"><span class="keywordtype">int</span> handle_program_memory_depletion( <span class="keywordtype">size_t</span> )</div><div class="line">{</div><div class="line">   <span class="comment">// Your code</span></div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )</div><div class="line">{</div><div class="line">   _set_new_handler( handle_program_memory_depletion );</div><div class="line">   <span class="keywordtype">int</span> *pi = <span class="keyword">new</span> <span class="keywordtype">int</span>[BIG_NUMBER];</div><div class="line">}</div></div><!-- fragment --><p>In Visual C++ .NET 2003, you can use <b>_set_security_error_handler()</b> function to handle buffer overrun errors. This function is declared deprecated and is removed from CRT in later versions of VC++.</p>
<p>Use the <b>_set_invalid_parameter_handler()</b> function to handle situations when CRT detects an invalid argument in a system function call. This function can be used in VC++ 2005 and later. This function works for all threads of the caller process.</p>
<p>Example (taken from MSDN):</p>
<div class="fragment"><div class="line"><span class="comment">// crt_set_invalid_parameter_handler.c</span></div><div class="line"><span class="comment">// compile with: /Zi /MTd</span></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;crtdbg.h&gt;</span>  <span class="comment">// For _CrtSetReportMode</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myInvalidParameterHandler(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* expression,</div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* <span class="keyword">function</span>, </div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* file, </div><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line, </div><div class="line">   uintptr_t pReserved)</div><div class="line">{</div><div class="line">   wprintf(L<span class="stringliteral">&quot;Invalid parameter detected in function %s.&quot;</span></div><div class="line">            L<span class="stringliteral">&quot; File: %s Line: %d\n&quot;</span>, <span class="keyword">function</span>, file, line);</div><div class="line">   wprintf(L<span class="stringliteral">&quot;Expression: %s\n&quot;</span>, expression);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main( )</div><div class="line">{</div><div class="line">   <span class="keywordtype">char</span>* formatString;</div><div class="line"></div><div class="line">   _invalid_parameter_handler oldHandler, newHandler;</div><div class="line">   newHandler = myInvalidParameterHandler;</div><div class="line">   oldHandler = _set_invalid_parameter_handler(newHandler);</div><div class="line"></div><div class="line">   <span class="comment">// Disable the message box for assertions.</span></div><div class="line">   _CrtSetReportMode(_CRT_ASSERT, 0);</div><div class="line"></div><div class="line">   <span class="comment">// Call printf_s with invalid parameters.</span></div><div class="line"></div><div class="line">   formatString = NULL;</div><div class="line">   printf(formatString);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="cpp_signals"></a>
C++ Signal Handling</h1>
<p>C++ provides program interruption mechanism called signals. You can handle signals with the <b>signal()</b> function.</p>
<p>In Visual C++, there are 6 types of signals:</p>
<ul>
<li><code>SIGABRT</code> Abnormal termination</li>
<li><code>SIGFPE</code> Floating-point error</li>
<li><code>SIGILL</code> Illegal instruction</li>
<li><code>SIGINT</code> CTRL+C signal</li>
<li><code>SIGSEGV</code> Illegal storage access</li>
<li><code>SIGTERM</code> Termination request</li>
</ul>
<p>MSDN says that the <code>SIGILL</code>, <code>SIGSEGV</code>, and <code>SIGTERM</code> signals are not generated under Windows NT and included for ANSI compatiblity. However, if you set the SIGSEGV signal handler in the main thread, it is called by CRT instead of SEH exception handler set with <b>SetUnhandledExceptionFilter()</b> function and the global variable <b>_pxcptinfoptrs</b> contains a pointer to the exception information. In other threads the exception filter set with <b>SetUnhandledExceptionFilter()</b> function is called instead of SIGSEGV handler.</p>
<p>The <b>_pxcptinfoptrs</b> can be also used in the SIGFPE handler. In all other signal handlers it seems to be NULL.</p>
<p>The SIGFPE signal handler is called by CRT when a floating point error occurs, such as division by zero. However, by default floating point exceptions are not generated, instead NaN or infinity numbers are generated as the result of a floating point operation. Use the <b>_controlfp_s()</b> function to enable the floating point exception generation.</p>
<p>You can generate all 6 signals manually using <b>raise()</b> function.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> sigabrt_handler(<span class="keywordtype">int</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// Caught SIGABRT C++ signal</span></div><div class="line"></div><div class="line">  <span class="comment">// Terminate program</span></div><div class="line">  exit(1);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">  signal(SIGABRT, sigabrt_handler);</div><div class="line">     </div><div class="line">  <span class="comment">// Cause abort</span></div><div class="line">  abort();       </div><div class="line">}                </div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Although it is not well documented in MSDN, it seems that you should install SIGFPE, SIGILL and SIGSEGV signal handlers for each new thread in your program. The SIGABRT, SIGINT and SIGTERM signal handlers seems to work for all threads of the caller process, so you should install them once in your <b>main()</b> function.</dd></dl>
<h1><a class="anchor" id="getting_exception_context"></a>
Retrieving Exception Information</h1>
<p>When an exception occurs you typically want to get the CPU state to determine the place in your code that caused the problem. You use the information to debug the problem. The way you retrieve the exception information differs depending on the exception handler you use.</p>
<p>In the SEH exception handler set with the <b>SetUnhandledExceptionFilter()</b> function, the exception information is retrieved from <b>EXCEPTION_POINTERS</b> structure passed as function parameter.</p>
<p>In __try{}__catch(Expression){} construction you retrieve exception information using <b>GetExceptionInformation()</b> intrinsic function and pass it to the SEH exception filter function as parameter.</p>
<p>In the SIGFPE and SIGSEGV signal handlers you can retrieve the exception information from the <b>_pxcptinfoptrs</b> global CRT variable that is declared in &lt;signal.h&gt;. This variable is not documented well in MSDN.</p>
<p>In other signal handlers and in CRT error handlers you have no ability to easily extract the exception information. I found a workaround used in CRT code (see CRT 8.0 source files, invarg.c, line 104).</p>
<p>The following code shows how to get current CPU state used as exception information.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if _MSC_VER&gt;=1300</span></div><div class="line"><span class="preprocessor">#include &lt;rtcapi.h&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef _AddressOfReturnAddress</span></div><div class="line"></div><div class="line"><span class="comment">// Taken from: http://msdn.microsoft.com/en-us/library/s975zw7k(VS.71).aspx</span></div><div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div><div class="line"><span class="preprocessor">#define EXTERNC extern &quot;C&quot;</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#define EXTERNC</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// _ReturnAddress and _AddressOfReturnAddress should be prototyped before use </span></div><div class="line">EXTERNC <span class="keywordtype">void</span> * _AddressOfReturnAddress(<span class="keywordtype">void</span>);</div><div class="line">EXTERNC <span class="keywordtype">void</span> * _ReturnAddress(<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line"><span class="preprocessor">#endif </span></div><div class="line"></div><div class="line"><span class="comment">// The following function retrieves exception info</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> GetExceptionPointers(DWORD dwExceptionCode, </div><div class="line">  EXCEPTION_POINTERS** ppExceptionPointers)</div><div class="line">{</div><div class="line">  <span class="comment">// The following code was taken from VC++ 8.0 CRT (invarg.c: line 104)</span></div><div class="line">  </div><div class="line">  EXCEPTION_RECORD ExceptionRecord;</div><div class="line">  CONTEXT ContextRecord;</div><div class="line">  memset(&amp;ContextRecord, 0, <span class="keyword">sizeof</span>(CONTEXT));</div><div class="line">  </div><div class="line"><span class="preprocessor">#ifdef _X86_</span></div><div class="line"></div><div class="line">  __asm {</div><div class="line">      mov dword ptr [ContextRecord.Eax], eax</div><div class="line">      mov dword ptr [ContextRecord.Ecx], ecx</div><div class="line">      mov dword ptr [ContextRecord.Edx], edx</div><div class="line">      mov dword ptr [ContextRecord.Ebx], ebx</div><div class="line">      mov dword ptr [ContextRecord.Esi], esi</div><div class="line">      mov dword ptr [ContextRecord.Edi], edi</div><div class="line">      mov word ptr [ContextRecord.SegSs], ss</div><div class="line">      mov word ptr [ContextRecord.SegCs], cs</div><div class="line">      mov word ptr [ContextRecord.SegDs], ds</div><div class="line">      mov word ptr [ContextRecord.SegEs], es</div><div class="line">      mov word ptr [ContextRecord.SegFs], fs</div><div class="line">      mov word ptr [ContextRecord.SegGs], gs</div><div class="line">      pushfd</div><div class="line">      pop [ContextRecord.EFlags]</div><div class="line">  }</div><div class="line"></div><div class="line">  ContextRecord.ContextFlags = CONTEXT_CONTROL;</div><div class="line"><span class="preprocessor">#pragma warning(push)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4311)</span></div><div class="line">  ContextRecord.Eip = (ULONG)_ReturnAddress();</div><div class="line">  ContextRecord.Esp = (ULONG)_AddressOfReturnAddress();</div><div class="line"><span class="preprocessor">#pragma warning(pop)</span></div><div class="line">  ContextRecord.Ebp = *((ULONG *)_AddressOfReturnAddress()-1);</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#elif defined (_IA64_) || defined (_AMD64_)</span></div><div class="line"></div><div class="line">  <span class="comment">/* Need to fill up the Context in IA64 and AMD64. */</span></div><div class="line">  RtlCaptureContext(&amp;ContextRecord);</div><div class="line"></div><div class="line"><span class="preprocessor">#else  </span><span class="comment">/* defined (_IA64_) || defined (_AMD64_) */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">  ZeroMemory(&amp;ContextRecord, <span class="keyword">sizeof</span>(ContextRecord));</div><div class="line"></div><div class="line"><span class="preprocessor">#endif  </span><span class="comment">/* defined (_IA64_) || defined (_AMD64_) */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">  ZeroMemory(&amp;ExceptionRecord, <span class="keyword">sizeof</span>(EXCEPTION_RECORD));</div><div class="line"></div><div class="line">  ExceptionRecord.ExceptionCode = dwExceptionCode;</div><div class="line">  ExceptionRecord.ExceptionAddress = _ReturnAddress();</div><div class="line"></div><div class="line">  </div><div class="line">  EXCEPTION_RECORD* pExceptionRecord = <span class="keyword">new</span> EXCEPTION_RECORD;</div><div class="line">  memcpy(pExceptionRecord, &amp;ExceptionRecord, <span class="keyword">sizeof</span>(EXCEPTION_RECORD));</div><div class="line">  CONTEXT* pContextRecord = <span class="keyword">new</span> CONTEXT;</div><div class="line">  memcpy(pContextRecord, &amp;ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));</div><div class="line"></div><div class="line">  *ppExceptionPointers = <span class="keyword">new</span> EXCEPTION_POINTERS;</div><div class="line">  (*ppExceptionPointers)-&gt;ExceptionRecord = pExceptionRecord;</div><div class="line">  (*ppExceptionPointers)-&gt;ContextRecord = pContextRecord;  </div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="cxx_compiler_flags"></a>
Visual C++ Compiler Flags</h1>
<p>There are several Visual C++ compiler switches that are related to exception handling. You can find the switches if open project Properties-&gt;Configuration Properties-&gt;C/C++-&gt;Code Generation.</p>
<p><b>Exception Handling Model</b></p>
<p>You set an exception handling model for your Visual C++ compiler with <b>/EHs</b> (or <b>EHsc</b>) to specify synchronous exception handling model or <b>/EHa</b> to specify asynchronous exception handling model. See the <em>/EH (Exception Handling Model)</em> in the Reference section below for more information.</p>
<p><b>Floating Point Exceptions</b></p>
<p>You enable floating point exceptions using <b>/fp:except</b> compiler flag. For more information, see the <em> /fp (Specify Floating Point Behavior)</em> in the Reference section below.</p>
<p><b>Buffer Security Checks</b></p>
<p>By default you have the <b>/GS</b> (Buffer Security Check) compiler flag enabled that force compiler to inject code that would check buffer overruns. A buffer overrun is a situation when a large block of data is written to a small buffer. When a buffer overrun is detected, CRT calls internal security handler that invokes Watson directly. For more information, see the <em> /GS (Buffer Security Check)</em> in the Reference section below.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>In Visual C++ .NET (CRT 7.1) you can use <b>_set_security_error_handler</b> function that CRT calls when buffer overrun is detected. However, this function is deprecated in the later versions of CRT.</p>
<p>Since CRT 8.0 you can't intercept security errors in your code. When buffer overrun is detected, CRT invokes Watson directly instead of calling unhandled exception filter. This is done because of security reasons and Microsoft doesn't plan to change this behavior.</p>
<p>For additional info please see these links:</p><ul>
<li><a href="https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101337">https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101337</a></li>
<li><a href="http://blog.kalmbachnet.de/?postid=75">http://blog.kalmbachnet.de/?postid=75</a></li>
</ul>
<h1><a class="anchor" id="crt_version_and_dll"></a>
Exception Handling and CRT Linkage</h1>
<p>Each module (EXE, DLL) in your application is linked to CRT (C run-time libraries). You may link CRT as multi-threaded static library or as multi-threaded dynamic link library. When you set CRT error handlers, such as terminate handler, unexpected handler, pure call handler, invalid parameter handler, new operator error handler or a signal handler, they will work for the CRT the caller module is linked to and won't intercept exceptions in different CRT modules (if exist), because each CRT module has its own internal state.</p>
<p>Several project modules may share single CRT DLL. This reduces to minimum the overall size of linked CRT code. And all exceptions within that CRT DLL can be handled at once. That's why multi-threaded CRT DLL is the recommended way of CRT linkage.</p>
<p>If you plan to use CRT as a static link library (which is not recommended to do) and want to use some crash reporting functionality, you have to build the functionality as a static library with /NODEFAULTLIB linker flag and then link this functionality to each EXE and DLL module of your application. You would also have to install the CRT error handlers for each module of your application, while the SEH exception handler would still be installed once.</p>
<p>For additional info about C run-time libraries (CRT), see the <em>C Run-time Libraries (CRT)</em> link in the Reference section below.</p>
<p>See also:</p><ul>
<li><a class="el" href="configuring_project.html#crtdll">Using CRT as Multi-Threaded DLL (/MD) in Release Configuration</a></li>
<li><a class="el" href="configuring_project.html#crtver">Using the Same Version of CRT for All Application Modules</a></li>
</ul>
<h1><a class="anchor" id="exception_handling_reference"></a>
Reference</h1>
<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/x057540h%28VS.80%29.aspx">Exception Handling in Visual C++</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms680634%28VS.85%29.aspx">SetUnhandledExceptionFilter()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms680552%28VS.85%29.aspx">RaiseException()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms679357%28VS.85%29.aspx">GetExceptionInformation()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms679356%28VS.85%29.aspx">GetExceptionCode()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/t6fk7h29%28VS.71%29.aspx">set_terminate()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/h46t5b69%28VS.71%29.aspx">set_unexpected()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/5z4bw5h5%28VS.71%29.aspx">_set_se_translator()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms395801%28VS.71%29.aspx">_set_security_error_handler()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/t296ys27%28VS.71%29.aspx">_set_purecall_handler()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/a45x8asx%28VS.71%29.aspx">_set_new_handler()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/a9yf33zb%28VS.80%29.aspx">_set_invalid_parameter_handler()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/xdkz3x12%28VS.71%29.aspx">signal()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/dwwzkt4c%28VS.71%29.aspx">raise()</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/1deeycx5%28VS.80%29.aspx">/EH (Exception Handling Model)</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/e7s85ffb%28VS.80%29.aspx">/fp (Specify Floating-Point Behavior)</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/8dbf701c%28VS.80%29.aspx">/GS (Buffer Security Check)</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/abx4dbyh%28VS.80%29.aspx">C Run-time Libraries (CRT)</a></li>
<li><a href="http://msdn.microsoft.com/en-us/magazine/cc301714.aspx">Under the Hood: New Vectored Exception Handling in Windows XP</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms681420%28VS.85%29.aspx">Vectored Exception Handling</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms679274%28VS.85%29.aspx">AddVectoredExceptionHandler Function</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms680571%28VS.85%29.aspx">RemoveVectoredExceptionHandler Function</a> </li>
</ul>
</div></div><!-- contents -->
<hr size="1"><address style="text-align: right;"><small>
Generated on Fri Apr 21 2017 15:24:31 for CrashRpt by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.13</small></address>
</body>
</html>
